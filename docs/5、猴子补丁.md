有时候，测试用例需要调用某些依赖于全局配置的功能，或者这些功能本身又调用了某些不容易测试的代码（例如：网络接入）。`fixture monkeypatch`可以帮助你安全的**设置/删除**一个属性、字典项或者环境变量，甚至改变导入模块时的`sys.path`路径。

`monkeypatch`提供了以下方法：

```python
monkeypatch.setattr(obj, name, value, raising=True)
monkeypatch.delattr(obj, name, raising=True)
monkeypatch.setitem(mapping, name, value)
monkeypatch.delitem(obj, name, raising=True)
monkeypatch.setenv(name, value, prepend=False)
monkeypatch.delenv(name, raising=True)
monkeypatch.syspath_prepend(path)
monkeypatch.chdir(path)
```

所有的修改将在测试用例或者`fixture`执行完成后撤销。`raising`参数表明：当**设置/删除**操作的目标不存在时，是否上报`KeyError`和`AttributeError`异常。


## 常用的使用场景

### 修改一个函数的功能或者类的属性
使用`monkeypatch.setattr()`可以将函数或者属性修改为你希望的行为，使用`monkeypatch.delattr()`可以删除测试用例使用的函数或者属性；

参考以下两个例子：

- 在这个例子中，使用`monkeypatch.setattr()`修改`Path.home`方法，在测试运行期间，它一直返回的是固定的`Path("/abc")`，这样就移除了它在不同平台上的依赖；测试运行完成后，对`Path.home`的修改会被撤销；

  ```python
  # src/chapter-5/test_module.py

  from pathlib import Path


  def getssh():
      return Path.home() / ".ssh"


  def test_getssh(monkeypatch):
      def mockreturn():
          return Path("/abc")

      # 替换 Path.home
      # 需要在真正的调用之前执行
      monkeypatch.setattr(Path, "home", mockreturn)
      
      # 将会使用 mockreturn 代替 Path.home
      x = getssh()
      assert x == Path("/abc/.ssh")
  ```

- 在这个例子中，使用`monkeypatch.setattr()`结合类，模拟函数的返回对象；
  
  假设我们有一个简单的功能，访问一个`url`返回网页内容：

  ```python
  # src/chapter-5/app.py

  from urllib import request


  def get(url):
      r = request.urlopen(url)
      return r.read().decode('utf-8')
  ```

  我们现在要去模拟`r`，它需要一个`.read()`方法返回的是`bytes`的数据类型；我们可以在测试模块中定义一个类来代替`r`：

  ```python
  # src/chapter-5/test_app.py

  from urllib import request

  from app import get


  # 自定义的类模拟 urlopen 的返回值
  class MockResponse:

      # 永远返回一个固定的 bytes 类型的数据
      @staticmethod
      def read():
          return b'luizyao.com'


  def test_get(monkeypatch):
      def mock_urlopen(*args, **kwargs):
          return MockResponse()

      # 使用 request.mock_urlopen 代替 request.urlopen
      monkeypatch.setattr(request, 'urlopen', mock_urlopen)

      data = get('https://luizyao.com')
      assert data == 'luizyao.com'
  ```

  > 你可以继续为实际的场景构建更具有复杂度的`MockResponse`；例如，你可以包含一个总是返回`True`的`ok`属性，或者根据输入的字符串为`read()`返回不同的值；

  我们也可以通过`fixture`跨用例共享：

  ```python
  import pytest


  # monkeypatch 是 function 级别作用域的，所以 mock_response 也只能是 function 级别，
  # 否则会报 ScopeMismatch 
  @pytest.fixture
  def mock_response(monkeypatch):
      def mock_urlopen(*args, **kwargs):
          return MockResponse()

      # 使用 request.mock_urlopen 代替 request.urlopen
      monkeypatch.setattr(request, 'urlopen', mock_urlopen)


  # 使用 mock_response 代替原先的 monkeypatch
  def test_get_fixture1(mock_response):
      data = get('https://luizyao.com')
      assert data == 'luizyao.com'


  # 使用 mock_response 代替原先的 monkeypatch
  def test_get_fixture2(mock_response):
      data = get('https://bing.com')
      assert data == 'luizyao.com'
  ```

  > 注意：
  >
  > - 测试用例使用的`fixture`由原先的`mock_response`替换为`monkeypatch`；
  > - 因为`monkeypatch`是`function`级别作用域的，所以`mock_response`也只能是`function`级别，否则会报`ScopeMismatch: You tried to access the 'function' scoped fixture 'monkeypatch' with a 'module' scoped request object `错误； 
  > - 如果你想让`mock_response`应用于所有的测试用例，可以考虑将它移到`conftest.py`里面，并标记`autouse=True`； 
